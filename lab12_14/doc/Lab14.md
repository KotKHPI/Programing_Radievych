# Лабораторна робота № 13. Строки (Null-terminated C Strings)
## 1 Вимоги
* **1.1 Розробник**
	* Радєвич Владислав Романович,
        * студент групи КІТ – 320,
        * 15.12.2020 р.

* **1.2 Загальне завдання** 
\n Розробити програми, умови яких надано у лабораторному практикуму.  Мною було взято умови для розробки з розділу на оцінку «відмінно».

* **1.3 Індивідуальне завдання** 
\n Зробити звіт за обраним мною варіантом. На даний момент це завдання номер 3. 

## 2 Опис програми
**2.1 Функціональне призначення** 
    Програма призначена вирахування частотної таблиці символі у 
заданому тексті за допомогою функціям роботи зі рядками..

**2.2 Опис логічної структури**

*   **Основна функція** 
   \n int `main`
   	\n *Призначення*: головна функція
   	\n *Схема алгоритму функції* подана на рис.1
   	\n *Опис роботи*: задає розмір масивам, змінним, виділяючи їм 
       пам'ять та звільня її. Викликає функції count_text_length, 
       count_of_unique_elements, fill_zeros, get_symbols, get_symbols_counts, 
       get_symbols_frequencies.

![Рисунок 1.1 - Схема алгоритму функції main](assets/flowchart_main(1).png)
![Рисунок 1.2 - Схема алгоритму функції main](assets/flowchart_main(2).png)


*   **Функція знаходження кількості слів**
    \n int count_text_length(char* arr);
    	\n *Призначення*: знаходження кількості слів у заданому тексті.
    	\n *Схема алгоритму функції* подана на рис.2
    	\n *Опис роботи*: функція розділяє заданий текст на окремі слова, та 
        рахує их.

![Рисунок 2 – схема алгоритму функції count_t_text_length](assets/count_t_text_length.png)
     
*    **Функція знаходження кількість символів, які дублюються та 
знаходить довжину рядка унікальних символів**
     \n int count_of_unique_elements(char* arr, int size);
     	\n *Призначення*: знаходження всіх символів, що дублюються в 
         заданому рядку та знаходження кількості унікальних символів, що є 
         результатом функції.
    	\n *Схема алгоритму функції* подана на рис.3
    	\n *Опис роботи*: функція знаходе всі символи, що дублюються в 
        заданому рядку та знаходить кількості унікальних символів, що є 
        результатом функції.
    	
![Рисунок 3 – схема count_of_unique_elements](assets/count_of_unique_elements.png)
    	
*    **Допоміжна функція**
     \n bool checker(char *arr, int currentIndex, char value);
     	\n *Призначення*: знаходження символів, що дублюються..
    	\n *Схема алгоритму функції* подана на рис.4
    	\n *Опис роботи*: функція перевіряє кожен елемента масиву на 
        повтор: результатом функції є логічний тип, які набуває значення «так» 
        або «ні».
    	
![Рисунок 4 – схема алгоритму функції fillingResult](assets/checker.png)

*    **Функція очищення масиву**
     \n void fill_zeros(int *arr, int size);
         \n *Призначення*: очистити масив, заповнюючи його нулями.
        \n *Схема алгоритму функції* подана на рис.5
        \n *Опис роботи*: функція присвоює кожному елементу масиву значення 0.
        
![Рисунок 5 – схема алгоритму функції fill_zeros](assets/fill_zeros.png)

*    **Функція виділення унікальних символів**
     \n void get_symbols(char *strIn, int sizeIn, char *symbols);  
         \n *Призначення*: виділення перших унікальних символів зі заданого тексту.
        \n *Схема алгоритму функції* подана на рис.6
        \n *Опис роботи*: функція виділяє унікальні символи з заданого тексту за переписує їх в окремий масив.
        
![Рисунок 6 – схема алгоритму функції get_symbols](assets/get_symbols.png)

*    **Функція присвоєння кількості**
     \n void get_symbols_counts(char* strIn, int sizeIn, char* elements, int* elCounts, int sizeOut);
         \n *Призначення*: визначити кількість символів, що повторюються та записати це значення в окремий масив.
        \n *Схема алгоритму функції* подана на рис.7
        \n *Опис роботи*: функція присвоює кожному унікальному символу його кількість повторення до переписання тексту в один рядок тільки з унікальними символами.
        
![Рисунок 7 – схема алгоритму функції get_symbols_counts](assets/get_symbols_counts.png)

*    **Функція визначення частоти**
     \n void get_symbols_frequencies(int* elCounts, float* elFreaqs, int size, int totalCount);  
         \n *Призначення*: визначити частоту символів, що повторюються та записати це значення в окремий масив.
        \n *Схема алгоритму функції* подана на рис.8
        \n *Опис роботи*: функція присвоює кожному унікальному символу його частота повторення до переписання тексту в один рядок тільки з унікальними символами..
        
![Рисунок 8 – схема алгоритму функції get_symbols_frequencies](assets/get_symbols_frequencies.png)

**Структура програми**
```
.
├── 1
│   ├── README.md
│   └── src
│       ├── lib.c
│       ├── lib.h
│       └── main.c
├── 2
│   ├── README.md
│   └── src
│       ├── lib.c
│       ├── lib.h
│       └── main.c
├── 3
│   ├── README.md
│   └── src
│       ├── lib.c
│       ├── lib.h
│       └── main.c
├── doc
│   ├── assets
│   │   ├── 9.png
│   │   ├── 10.png
│   │   ├── 11.png
│   │   ├── checker.png
│   │   ├── count_of_unique_elements.png
│   │   ├── count_text_length.png
│   │   ├── fill_zeros.png
│   │   ├── flowchart_main(1).png
│   │   ├── flowchart_main(2).png
│   │   ├── get_symbols_counts.png
│   │   ├── get_symbols_frequencies.png
│   │   └── get_symbols.png
│   ├── Lab13.md
│   └── Radievych13.pdf
├── Doxyfile
├── Makefile
└── README.md

```

## 3 Варіанти використання
Цю програму можна використовувати за для знаходження частоти повторення символів з заданому тексті 
	\nРезультат роботи з doxygen продемонстровано на рисунку 9, рисунку 10 та рисунку 11. 

![Рисунок 5 – робота з doxygen](assets/9.png)

![Рисунок 6 – робота з doxygen](assets/10.png)

![Рисунок 7 – робота з doxygen](assets/11.png)


## Висновки
При виконанні даної лабораторної роботи я закріпив набуті мною навички, створення програми, використовуючи функції роботи з рядками.
